<!DOCTYPE html>
<html>
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta charset="utf-8">
<title>活跃网络的前端工程化实践之路 - ACTIVE Front-End Enginnering</title>
<meta name="description" content="">
<meta name="author" content="">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1">
<link rel="stylesheet" href="../assets/css/bulma.min.css">
<link rel="stylesheet" href="../assets/css/app.css">
<!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->
<link rel="shortcut icon" href="">
</head>
<body dir="LTR">

<nav class="columns navbar">
  <div class="column logo is-3 is-offset-1">
    <a class="is-brand" href="../index.html">
      ACTIVE Front-End Enginnering
    </a>
  </div>
</nav>

<div class="columns content">
  <div class="column is-2-desktop is-3-widescreen is-hidden-touch">
  </div>
  <div class="column article-container is-11-tablet is-8-desktop is-6-widescreen">
    <div class="breadcrumb-area"><a href="../index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../active/index.html" class="breadcrumb-item">ACTIVE</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../active/2017-10-19-front-end-engineering-in-active.html" class="breadcrumb-item">活跃网络的前端工程化实践之路</a></div>
    <h1 class="article-title">活跃网络的前端工程化实践之路</h1>
    
  <p>作者：张新</p>


    <div class="article">
      <p>日期：2017-10-19</p>
<p>在活跃网络（成都）呆了三年半左右，搬过砖，踩过雷，架过构，管过人，想聊聊这些年在活跃网络的前端工程化实践之路。</p>
<h2 id="前端架构历史">前端架构历史 <a class="markdownIt-Anchor" href="#前端架构历史">#</a></h2>
<p>在 2014 年之前，活跃网络（ACTIVE Network）的前端技术架构基本可以分为以下两种类型，后端技术包括但不限于 Java, .NET, PHP, RoR，Adobe Flex 等等。</p>
<ul>
<li><a href="http://www.active.com/">以 <strong>jQuery</strong> 为基础的单体 <strong>Web App</strong></a></li>
<li><a href="https://endurance.active.com/">以 <strong>Backbone.js + RequireJS</strong> 为基础构建的基于 MVC 的 <strong>SPA</strong></a></li>
<li><strong>React</strong> 之路...</li>
</ul>
<p>很明显，在第一种方案中，是以后端为主的 MVC，前端开发重度依赖于后端的开发环境，并且前后端的职责纠缠不清（路由，模板到底应该放在前端还是后端？），很多时候前后端的代码会严重耦合。</p>
<p>而对于业务场景较复杂的系统，前后端的代码经常会混杂在一起，长此以往，可维护性以及可扩展性都将无从谈起，后面功能的开发也只能是在以前代码的基础上修修补补，直到无法忍受的一天就会产生重构的想法。</p>
<p>第二种方案中，是随着AJAX的兴起而带来的前端SPA时代。前端负责<strong>视图+路由+模板+AJAX</strong>，后端只是负责提供数据接口（RESTFul API，WebSocket 等等），从此前后端职责更加清晰，前端可以自由选择自己的框架，库，及至模块引擎，也可以进行合理的垂直分层，让各层各司其职，互相配合。</p>
<p>同时，在工程化实践过程中，我们遇到的挑战也是很明显的，主要有以下几个方面：</p>
<ul>
<li>前端没有统一的<strong>标准规范</strong>，包括底层技术选型（库，框架，工具，测试等等），开发工作流程，风格指南，代码规范等等</li>
<li>前端底层技术栈不统一，无法达到最大程度的复用，小到组件级别复用，大到流程的复用等等</li>
<li>前端没有统一的自动化工具，流程，如 CI/CD，全靠手动</li>
<li>前端没有测试（单元测试，集成测试或是自动化测试）来保证代码质量，基本是靠工程师自测，或是QA的手动测试外加部分自动化（只能覆盖核心流程且易经常变动）</li>
</ul>
<p>所有这些都是我们目前所遇到的挑战和必须要解决的难题，但是，有一点是始终没有变的，那就是最终前端工程化实践的核心诉求都是一致的：</p>
<blockquote>
<p>减少开发技术成本，提升产品迭代效率以及产品体验！！！</p>
</blockquote>
<h2 id="前端标准化">前端标准化 <a class="markdownIt-Anchor" href="#前端标准化">#</a></h2>
<p>对于前端标准化来说，我们要做的就是建立好前端的基础底层架构，规范开发技术选型，达到最大程度的复用，从而减少我们的开发技术成本，进而提升产品的迭代效率。</p>
<p>在这一方面，最近一年半时间内，我们做了很多工作，也有了很多产出。</p>
<h3 id="企业级的-css-框架">企业级的 <code>CSS</code> 框架 <a class="markdownIt-Anchor" href="#企业级的-css-框架">#</a></h3>
<p><strong>Active.css</strong> 是活跃网络内部的企业级 <code>CSS</code> 框架，它确保了整个活跃网络产品线可以保持一致的外观和行为，并且让我们可以很容易的去对整个产品线做更新。它所提供的数十几种灵活实用且可重用的组件，可以帮助我们在之后的开发过程中进一步提高生产力，并且，它也让所有的开发者，设计师，产品经理，以及市场人员可以参考同一套标准，做到有据可依，有理可循。</p>
<p>在过去，每个产品团队会实现一套自己的 <code>CSS</code> 样式库，所以常常会遇到一些问题：</p>
<ul>
<li>很难去维护和重用CSS样式</li>
<li>保持活跃网络所有产品线体验一致</li>
</ul>
<p>但是，有了 <strong>Active.css</strong> 帮助我们统一产品的风格指南，我们会有如下的优势：</p>
<ul>
<li>标准化</li>
</ul>
<p>整个公司可以共用一套 <strong>CSS</strong> 样式库，从而可以继续维持一个更高标准和最佳实践</p>
<ul>
<li>一致性</li>
</ul>
<p>针对开发者，设计师，产品经理，以及市场人员等等，建立了一套公共语言，并且让它应用到不同的产品的同时，还能继续保持一致性</p>
<ul>
<li>高效</li>
</ul>
<p>每个产品团队不用自己去开发和维护公共样式库，只需要重用一套代码标准规范。也就意味着，开发人员可以花更多的时间在构建业务上，而不是花在考虑应该如何写基础样式上</p>
<ul>
<li>可维护性</li>
</ul>
<p>以组件为最小单元来构建每个 <strong>CSS</strong> 组件，通过组合进而构建更为复杂的组件或者业务单元</p>
<p>另外，为了维持整体的CSS风格统一，也推出了 <em>CSS 风格指南</em>，它会提供一些关于CSS的最佳实践，如文件目录结构组织，命名，样式规则等等。</p>
<p><img src="/images/active-css-guidelines.png" alt="ACTIVE CSS Style Guidelines"></p>
<h3 id="基于-react-的-ui-组件库">基于 React 的 <strong>UI</strong> 组件库 <a class="markdownIt-Anchor" href="#基于-react-的-ui-组件库">#</a></h3>
<p>从 2016 年初开始，团队开始采用 <a href="https://facebook.github.io/immutable-js/">React</a> 作为构建前端视图的基础库，在这过程中，逐渐把公用组件剥离出来，使用得这些组件可以在各个项目中能够得到最大程度的复用。</p>
<p>组件主要包括以下几类：</p>
<ul>
<li>独立于业务的单一组件：<code>Button</code>，<code>Input</code>，<code>Dropdown</code>，<code>Table</code>，<code>Modal</code>，<code>DatePikcer</code>，<code>Pagination</code>等等</li>
<li>独立于业务的复合组件：<code>Form</code>，<code>CheckboxGroup</code>，<code>RadioGroup</code>，<code>SearchInput</code>，<code>Tabs</code>，<code>Table</code>，<code>TagEditor</code>等等</li>
<li>业务组件（需要在多个项目中重用）：<code>AddressEditor</code>，以及与<a href="http://fee.surge.sh/2017-09-18-how-do-we-implement-i18n-based-on-react.html">i18n相关的组件 API</a></li>
<li>工具组件：<code>ShowAt</code>，<code>HideAt</code>，<code>Viewport</code>等等</li>
</ul>
<p>每个组件所对应的样式定义都是单独放在 <strong>Active.css</strong> 中，也就是说，<strong>JS</strong> 和 <strong>CSS</strong> 是分开单独维护开发的。</p>
<p>为什么需要这样做呢？</p>
<p>活跃网络有很多存在了十几年的老项目，他们的实现方式多种多样，但是随着客户的需求变化，近年来他们都有一个统一的诉求，那就是『改头换面』，重新换上符合公司产品风格指南的全新的样式风格。但是为了尽量减少工作量，我们一般只做样式上的修改，而不是对整个应用做重构，内部称之为『Reskin』。</p>
<p>同时，我们也针对这套 UI 库，构建了它的线上 API文档，组件使用者可以通过它快速查询某个组件的API 接口规范，并且提供很方便的在线 <em>REPL</em>。</p>
<p><img src="/images/active-ui.png" alt="ACTIVE UI"></p>
<h3 id="git-工作流">Git 工作流 <a class="markdownIt-Anchor" href="#git-工作流">#</a></h3>
<h4 id="功能分支工作流">功能分支工作流 <a class="markdownIt-Anchor" href="#功能分支工作流">#</a></h4>
<p>为了提高开发效率，形成规范化的代码管理，活跃网络已经完成了从 SVN 到 Git 的迁移，内部采用的是<a href="https://www.atlassian.com/git/tutorials/comparing-workflows#feature-branch-workflow">功能分支工作流</a>，也就是说所有新功能的开发都是基于一个独立的功能分支，而不是传统的master分支。这样每个工程师都可以在属于自己的功能分支上开发，而不会影响到主分支，主分支可以随时发布上线，当然这得借助于自动化的 <strong>CI/CD</strong> 来保证。</p>
<h3 id="git-提交消息格式">Git 提交消息格式 <a class="markdownIt-Anchor" href="#git-提交消息格式">#</a></h3>
<p>当我们提交代码时，都会涉及到一个永恒不变的话题---<strong>如何给 <code>Commit</code> 加一段简短且有意义的描述</strong>。</p>
<h4 id="如何写-git-提交消息">如何写 Git 提交消息 <a class="markdownIt-Anchor" href="#如何写-git-提交消息">#</a></h4>
<p>那么我们应该如何写一个 <strong>Git 提交消息</strong>呢？</p>
<p>请移玉步至 <a href="https://chris.beams.io/posts/git-commit/">How to Write a Git Commit Message</a></p>
<p><strong>TLDR</strong>:</p>
<ul>
<li>用一个空行来分隔开主题和正文</li>
<li>主题限制在 50 个字符内</li>
<li>主题行以一个大写字母开始</li>
<li>主题行不要以点结尾</li>
<li>主题行使用命令式语气</li>
<li>正文的每行限制在72个字符内</li>
<li>使用正文来解释 what &amp; why，而不是 How</li>
</ul>
<p>目前团队内部参考的Git提交消息最佳实践是如下二个：</p>
<ul>
<li><a href="https://udacity.github.io/git-styleguide/">Udacity Git Commit Message Style Guide</a></li>
<li><a href="https://github.com/angular/angular.js/blob/master/CONTRIBUTING.md#commit-message-format">AngluarJS Commit Message Format</a></li>
</ul>
<p>二者大同小异，完全满足上面这七大原则，都可以帮助团队统一 <strong>Git 提交消息格式</strong>，从而与他人协作更加方便。</p>
<blockquote>
<p>推荐使用<a href="https://github.com/commitizen/cz-cli">commitizen</a>来帮助团队规范化整个流程，与npm scripts配合自动化整个流程。</p>
</blockquote>
<h4 id="自动检测-git-提交消息格式">自动检测 Git 提交消息格式 <a class="markdownIt-Anchor" href="#自动检测-git-提交消息格式">#</a></h4>
<p>随着团队人员增多，我们需要一种工具能够自动化帮助我们检测 Git 提交消息格式是否满足规范要求。推荐使用 <a href="https://github.com/marionebl/commitlint">marionebl/commitlint</a> 来自动化 Lint Git 提交的消息格式，并且配合 <em>prepush hook</em> 一起使用。</p>
<h4 id="自动生成changelog">自动生成<code>CHANGELOG</code> <a class="markdownIt-Anchor" href="#自动生成changelog">#</a></h4>
<p>如果是库或是框架的开发，我们需要提供 <em>CHANGELOG</em> ，以让团队内部和外部人员知道我们最近所做的更新，如修改的 Bugs，新增加的功能或是其它性能上的提升等等</p>
<p>如果需要根据 Git 的提交和其它元数据自动生成<em>CHANGELOG</em>，请参考 <a href="https://github.com/conventional-changelog/conventional-changelog">conventional-changelog/conventional-changelog</a> 命令行工具。</p>
<h3 id="前端技术选型">前端技术选型 <a class="markdownIt-Anchor" href="#前端技术选型">#</a></h3>
<p><a href="http://stateofjs.com/2016/frontend/">前端开发技术日新月异</a>，在做前端技术选型架构时，团队内部会充分考虑各个框架库的优缺点，选择更加贴合项目需求的成熟技术方案。</p>
<p>目的很简单，希望能够最大限度的帮助我们减少技术成本，提高迭代效率，运行效率，以及用户体验。</p>
<h4 id="single-page-appspa">Single Page App(SPA) <a class="markdownIt-Anchor" href="#single-page-appspa">#</a></h4>
<p>我们经常提到SPA，那么到底什么是SPA呢？</p>
<ul>
<li>它是一个单一的 <strong>HTML</strong> 页面</li>
<li>它在页面之间跳转时，不需要重新刷新</li>
<li>它使用 <strong>JavaScript</strong> 来编写业务逻辑，并运行在浏览器端</li>
<li>在用户与页面交互时，它可以部分更新页面</li>
<li>（可选）基于路由实现<a href="https://webpack.js.org/guides/code-splitting/#dynamic-imports">按需加载</a></li>
<li>（可选）基于 <a href="https://github.com/GoogleChrome/sw-precache">Service Worker</a> 提供离线支持</li>
</ul>
<blockquote>
<p>目前并没有使用 <strong>Node.js</strong> 来作为中间的 <strong>Web Server</strong> 层，前后端之间唯一的通信桥梁就是 <strong>Web API</strong>。如果之后需要支持 <strong>SSR</strong>（server-side rendering） 或是 <strong>State Persistence</strong> 等等时，会考虑在前后端之间添加 <strong>Node.js</strong> 层。</p>
</blockquote>
<h4 id="dev-environment">Dev Environment <a class="markdownIt-Anchor" href="#dev-environment">#</a></h4>
<p>如何管理好上万行代码前端单页应用是团队的一个核心挑战，一个良好的项目目录结构则是首要条件，具体内容，请参考 <a href="/react/2017-06-04-how-we-structure-react-redux-project-stucture.html">我们如何组织 React + Redux 项目结构</a>。</p>
<h4 id="react">React <a class="markdownIt-Anchor" href="#react">#</a></h4>
<p>使用 <a href="https://github.com/facebook/react">React <sub>视图层</sub></a>来构建基于组件的富用户界面层。React是基于组件化的设计，与前端的技术趋势（模块化，组件化）非常接近，在前端社区中也非常流行，支持者众多，并且它是由Facebook官方支持和亲身实践的，最近也修改为<a href="https://code.facebook.com/posts/300798627056246/relicensing-react-jest-flow-and-immutable-js/"> MIT 许可</a>。下面是很喜欢的一些 <strong>React</strong> 的特性：</p>
<ul>
<li>组合（Composition）</li>
<li>单向数据流（Unidirectional Dataflow）</li>
<li>声明式（Declarative）</li>
<li>显示变化（Explicit Mutations）</li>
<li>React API 简单，小而美</li>
<li>没有多余的概念，只是 <strong>JavaScript</strong></li>
<li>虚拟 DOM</li>
<li>函数式编程</li>
<li>SSR（服务端渲染）</li>
<li>...</li>
</ul>
<h4 id="types">Types <a class="markdownIt-Anchor" href="#types">#</a></h4>
<p>类型系统可以选择的很多，如 <strong><a href="https://reactjs.org/docs/typechecking-with-proptypes.html">prop-types</a></strong>，<strong><a href="https://flow.org/">flow</a></strong>，以及 <strong><a href="https://www.typescriptlang.org/">TypeScript</a></strong>。</p>
<p>我更倾向于 prop-types，因为它的侵入性很小，但是已经为 React 组件提供了足够的类型安全，另外再加上测试和 ESLint，在最近的项目中，很难发现运行时类型错误。</p>
<h4 id="router">Router <a class="markdownIt-Anchor" href="#router">#</a></h4>
<p>使用 <a href="https://github.com/ReactTraining/react-router">react-router@v4 <sub>Declarative routing for React</sub></a> 来作为客户端的路由解决方案，从而让用户可以在页面之间跳转而不需要重新刷新整个页面。从<strong>react-router@v4</strong>开始，它的基础代码全部被重写了，如今的<code>Route</code>更偏向于组件，它只是基于当前的URL是否与所设定的路径一致，从而决定显示或是隐藏组件，这也更加<strong>React</strong>，更加贴合组件化的思想。想了解更多的改变，请移玉步至 <a href="https://css-tricks.com/react-router-4/">All About React Router 4</a>。</p>
<h4 id="redux">Redux <a class="markdownIt-Anchor" href="#redux">#</a></h4>
<p>使用 <a href="http://redux.js.org/">Redux <sub>Predictable State Container</sub></a> 来构造和管理复杂的 <strong>Web App</strong> 状态，它能帮助我们解决：</p>
<ul>
<li>管理各种各样的状态：Domain数据，UI状态，App状态等等</li>
<li>在Web应用的整个生成周期中，在哪里保存所有的数据呢？</li>
<li>保存好这些数据后，应该如何处理这些数据的修改呢？</li>
<li>如何让整个Web应用知道到这些数据变化了呢？</li>
</ul>
<h4 id="redux-promise-middleware">Redux Promise Middleware <a class="markdownIt-Anchor" href="#redux-promise-middleware">#</a></h4>
<p>在整个Redux <strong>Web App</strong> 中，统一使用团队内部构建的Redux Promise Middleware来处理所有的副作用（异步逻辑），比如 <strong>RESTFul API</strong>。它与 <em>redux-thunk</em>， <em>redux-saga</em> 或是 <em>redux-obserable</em> 相比，它更适合我们团队的需求，简单易上手，基本满足我们的需求：</p>
<ul>
<li>相当于一个轻量级的库，专门用于 <strong>Resolve Promises</strong> 和 <strong>Reject Promises</strong> ，并且它是完全基于乐观更新的</li>
<li>让我们可以更加灵活的去处理Redux中的异步 <code>Actions</code>，同时依据一定的命名规范会自动派发 <code>${REQUEST}</code>, <code>${REQUEST}_SUCCESS</code> 和 <code>${REQUEST}_FAILURE</code> 的 <code>Actions</code></li>
</ul>
<h4 id="isomorphic-fetch">Isomorphic Fetch <a class="markdownIt-Anchor" href="#isomorphic-fetch">#</a></h4>
<p>基于 <a href="https://github.com/matthew-andrews/isomorphic-fetch">isomorphic-fetch</a> 封装了一套 <strong>api.js</strong>，作为 <strong>Web API</strong> 工具来处理 <strong>AJAX</strong> 的请求和返回。</p>
<h4 id="immutablejs"><code>Immutable.js</code> <a class="markdownIt-Anchor" href="#immutablejs">#</a></h4>
<p>使用 <a href="https://facebook.github.io/immutable-js/">Immutable.js</a> 来作为状态存储库。它提供了很多常用的 Persistent Immutable data structures 来帮助我们管理数据存储，并且保证它们是 Immutability 的。这就要求我们操作所有数据时，都要当作不可变数据（immutable data）来对待，保证每次都是全新对象，没有引用关系，这样才能保证State的独立性，便于测试和追踪变化。同样的，它也是来自于 Facebook，与 React 是天生一对。</p>
<h4 id="react-ui-组件库react-aui">React UI 组件库@<code>react-aui</code> <a class="markdownIt-Anchor" href="#react-ui-组件库react-aui">#</a></h4>
<p>使用基于 React 构建的 <strong>react-aui</strong> 作为基础的 UI 组件库，它包含了一系列满足我们的 <em>Product Style Guide</em> 的灵活，实用且可重用的组件。</p>
<h4 id="tempestjs"><code>Tempest.js</code> <a class="markdownIt-Anchor" href="#tempestjs">#</a></h4>
<p>内部开发和维护的一个基于 React + Redux 以及包含我们的一些最佳实践的框架，以帮助我们能够快速的构建 Web App.</p>
<h4 id="build-tools"><code>build-tools</code> <a class="markdownIt-Anchor" href="#build-tools">#</a></h4>
<p>之前，我们每次新建一个项目时，都需要去建立和配置很多工具集，包括测试，构建，发布，代码检查等等，因为已经有以前的成功经验，所以大多数时候直接 copy-and-paste 就搞定了。</p>
<p>但是，如果 Webpack 新版本性能提升了，然后需要升级了，又或是我们需要新增加一个 ESLint 规则，再或者是我们需要新增一个 <strong>prepush hook</strong> ，如 <code>commitlint</code>，然后我们又需要在每个项目里面单独维护，这大大影响我们的工作效率。</p>
<p><code>build-tools</code> 提供了我们常见的脚本 (build/release/lint/test/...)，并且允许高度自定义。 如果你需要维护多个项目的话，这样的工具可以让你更容易管理你的工具依赖并随时保持更新。</p>
<p>比如，如果你要扩展 Jest 配置，你可以这样做：</p>
<pre class="hljs"><code>const { jest: jestConfig } = require('build-tools/config')

const { setupFiles } = jestConfig

// Config it depending on your requirements
module.exports = Object.assign(jestConfig, {
  setupFiles: [
    '&lt;rootDir&gt;/test/polyfill.js',
    '&lt;rootDir&gt;/test/setup.js',
  ],
})

</code></pre>
<p><img src="/images/build-tools-package-diff.png" alt="build-tools-package-diff"></p>
<h4 id="styling">Styling <a class="markdownIt-Anchor" href="#styling">#</a></h4>
<p>对于 React 组件来说，我们可以数十种方式来为组件添加样式，比如内联样式，CSS，LESS/SASS, <a href="https://github.com/css-modules/css-modules">CSS Modules</a> 以及各种 <a href="https://github.com/MicheleBertoli/css-in-js">CSS-in-JS</a> 实现。</p>
<p>目前我们选用的是 <a href="http://lesscss.org/">LESS</a> + <a href="http://css/guidelines/">BEM</a>，但是 LESS 我们只限定使用它的 <em>Variables</em>， <em>Mixins</em> 和 <em>Nested Rules</em>，其它功能不推荐使用。</p>
<h4 id="yarn">Yarn <a class="markdownIt-Anchor" href="#yarn">#</a></h4>
<p>使用 <a href="https://yarnpkg.com/">Yarn</a> 来做为我们的包管理工具。</p>
<h4 id="jest">Jest <a class="markdownIt-Anchor" href="#jest">#</a></h4>
<p>使用 <a href="https://facebook.github.io/jest/">Jest</a> 和 <a href="https://github.com/airbnb/enzyme">Enzyme</a> 来作为测试的解决方案。</p>
<p>有一些特别的 Jest 配套工具推荐，以提高写测试效率：</p>
<ul>
<li><a href="https://github.com/adriantoine/enzyme-to-json#usage">enzyme-to-json</a>: Cutomize your serializer for Enzyme wrappers</li>
<li><a href="https://github.com/jest-community/snapshot-diff">snapshot-diff</a>: Diffing snapshot utility for Jest</li>
<li><a href="https://github.com/Thinkmill/jest-expect-contain-deep">jest-expect-contain-deep</a>: Assert deeply nested values in Jest</li>
</ul>
<p>如果想从其它测试框架迁移至 Jest，推荐 <a href="https://github.com/skovhus/jest-codemods">jest-codemods</a>。</p>
<h4 id="webpack">Webpack <a class="markdownIt-Anchor" href="#webpack">#</a></h4>
<p>使用 <a href="https://webpack.js.org/">Webpack</a> 来作为 Module Bundler，它提供了丰富的 Loaders 和 Plugins 来帮助我们处理各种各样的资源，同时它还支持 Tree Shaking 和 Code Splting，可以更好的帮助我们做组件化开发与资源的管理。</p>
<blockquote>
<p>根据增量的原则，我们应该精心规划每个页面的资源加载策略，使得用户无论访问哪个页面都能按需加载页面所需资源，没访问过的无需加载，访问过的可以缓存复用，最终带来流畅的应用体验。</p>
</blockquote>
<h4 id="其它">其它 <a class="markdownIt-Anchor" href="#其它">#</a></h4>
<ul>
<li>优先使用 <strong>ES6 Class</strong> 而不是 <strong><a href="https://reactjs.org/docs/react-without-es6.html">createClass</a></strong></li>
<li>优先使用 <strong><a href="https://hackernoon.com/react-stateless-functional-components-nine-wins-you-might-have-overlooked-997b0d933dbc">React Stateless Functional Component</a></strong> 而不是 ES6 Class Component</li>
<li>优先使用 <strong><a href="https://github.com/tc39/proposal-class-fields">Class Prop Arrow Function</a></strong> 来 Binding <code>this</code></li>
<li>优先使用 <strong><a href="https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce">Render Prop</a></strong> 而不是 <strong><a href="https://reactjs.org/docs/higher-order-components.html">HoC</a></strong> 来实现复用</li>
<li><a href="https://github.com/facebookincubator/create-react-app/issues/87#issuecomment-234627904">优先使用 <code>.js</code> 作为文件名后缀</a></li>
<li>每个文件只包含一个 React 组件或是一个函数</li>
<li>每个 React 组件/模块自包含，即 JS/CSS/... 包含在组件自己的目录中，文件名需要与默认导出名一致</li>
<li>如果某个组件/模块只在另外一个组件/模块中使用，那么就让它嵌套在另外一个组件/模块目录中</li>
</ul>
<h3 id="开发流程">开发流程 <a class="markdownIt-Anchor" href="#开发流程">#</a></h3>
<p>请移玉步至<a href="/2017-09-25-active-development-workflow.html">活跃网络前端开发流程</a>。</p>
<h3 id="项目目录结构">项目目录结构 <a class="markdownIt-Anchor" href="#项目目录结构">#</a></h3>
<p>请移玉步至<a href="/react/2017-06-04-how-we-structure-react-redux-project-stucture.html">我们如何组织 React + Redux 项目结构</a>。</p>
<h3 id="风格指南和代码规范eslint-prettier">风格指南和代码规范（ESLint + Prettier） <a class="markdownIt-Anchor" href="#风格指南和代码规范eslint-prettier">#</a></h3>
<p>风格指南是代码规范的其中一种形式，它针对的是单个文件的布局，而代码风格更加强调的是一些编程最佳实践，文件和目录的设计等等。</p>
<p><strong>JavaScript</strong> 是一门动态并且类型松散的语言，再加上团队成员水平参差不齐，急需要一种工具可以帮助我们发现代码中常见的 Bugs 或是潜在的问题，提高代码质量，保持团队代码风格一致。因此我们引入了<a href="https://eslint.org/">ESLint</a>作为代码的静态分析工具，并自动集成到我们的CI/CD流程中，也就是一旦发现ESLint错误，那么整个CI/CD会失败，直到修复这些错误为止。</p>
<p>另外，ESLint支持创建 <a href="https://eslint.org/docs/developer-guide/shareable-configs">ESLint Shareable Configs</a>，团队内部基于 <a href="https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb">eslint-airbnb</a> 创建了适应自己的 <em>ESLint Shareable Config</em>。</p>
<p>最近，我们也集成了 <a href="https://github.com/prettier/prettier">Prettier</a> 来作为代码格式化工具，之后，<strong>Prettier</strong> 会主要负责代码风格一致，而 <strong>ESLint</strong> 会确保我们的代码质量是满足最佳实践的，各自分工，互不耽误。</p>
<p><img src="/images/eslintrc.png" alt=".eslintrc"></p>
<h3 id="测试">测试 <a class="markdownIt-Anchor" href="#测试">#</a></h3>
<p>前端的测试解决方案是基于 <strong>Jest + Enzyme</strong> 的，并且会添加 <strong>prepush hook</strong>，以确保在提交代码前，至少在本地机器上跑测试通过的。</p>
<p>基本上，我们会要求单元测试的代码覆盖率至少是要达到<strong>百分之九十</strong>的，它表示的是 <em>Statements</em>，<em>Branches</em>，<em>Functions</em>，<em>Lines</em> 这四个维度的平均值。有了这些测试后，在之后的开发，重构或是修复 Bug 中，我们就可以依据需求任意的做出相应的修改，同时，我们也有足够的信心不会破坏已有的代码。</p>
<p><img src="/images/jest.config.js.png" alt="jest.config.js"></p>
<h3 id="自动化-cicd">自动化 - CI/CD <a class="markdownIt-Anchor" href="#自动化-cicd">#</a></h3>
<p><strong>CI</strong> 也就是我们经常说的持续集成，指的是频繁地（或者是一天多次）将代码集成到主干分支，它现在是我们开发流程中必不可少的一环。它主要可以帮助我们：</p>
<ul>
<li>快速发现错误。每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。</li>
<li>防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。</li>
</ul>
<p>持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。</p>
<p><strong>CD</strong>也就是持续交付（Continuous delivery），它指的是频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。
持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。</p>
<p>在 ACTIVE Network，工程师在自己的分支上完成代码开发后，会先提交一个 Gitlab Merge Request(MR，类似 GitHub 的 PR)，以供团队其它成员做 Code Review。代码仓库都会预先设置好 <a href="https://docs.gitlab.com/ce/user/project/integrations/webhooks.html">Webhook</a>，所以只要有创建，更新或是合并 MR 时，都会自动运行仓库的 <a href="https://jenkins.io/doc/book/pipeline/getting-started/">Jenkins Pipeline</a>，下面是一个典型的 <strong>Jenkinsfile</strong>：</p>
<p><img src="/images/Jenkinsfile.png" alt="Jenkinsfile"></p>
<p>一般来说，它会执行如下的步骤：</p>
<ol>
<li>拉出最新的需要合并的分支代码</li>
<li>安装依赖</li>
<li>运行 Lint 脚本</li>
<li>运行测试（包括单元测试和集成测试）</li>
<li>发布测试代码覆盖率报告</li>
</ol>
<h2 id="发布">发布 <a class="markdownIt-Anchor" href="#发布">#</a></h2>
<p>通过 CI 流程，代码已经可以合并到主干分支了，我们就可以基于它做发布。一般发布流程包括：</p>
<ul>
<li>运行ESLint</li>
<li>运行测试</li>
<li>构建（Webpack）</li>
<li>在 <code>package.json</code> 中升级版本号（如果没有版本，则只升级PATCH版本）</li>
<li>创建一个新的提交</li>
<li>创建一个叫 <code>v*</code> 的标签（如 v1.15.35 ），并指向上一步创建的提交</li>
<li>推送至远程分支(master)</li>
<li>以 <strong>zip</strong> 格式将构建成功的前端资源文件（HTML, JS, CSS, FONTS等等）打包，并发布到远端的Nexus服务器</li>
<li>推送 <code>v*</code> 标签至远程仓库</li>
<li>创建并推送 <code>latest</code> 标签至远程仓库</li>
</ul>
<p>这样一来，前端代码库拥有了自己的版本管理，并且每个打包的版本只是一些构建后的 HTML/JS/CSS/Fonts 的集合，任意的后端服务都可以使用它。</p>
<h2 id="部署">部署 <a class="markdownIt-Anchor" href="#部署">#</a></h2>
<p>一般会在 Jenkins CI 机器上执行如下步骤：</p>
<ul>
<li>首先从 <code>package.json</code> 中获取最新的版本号</li>
<li>后端的生产服务器在部署前，会先备份当前代码</li>
<li>从远程的 <strong>Nexus</strong> 服务器上下载指定版本（第一步中获取的）的前端代码库，之后将打包文件解压到本地的一个目录</li>
<li>之后再将运行路径的符号链接指向这个目录或者是通过 <strong>Rsync</strong> 将解压文件传输至生产服务器上指定目录中</li>
<li>重新启动应用</li>
</ul>
<p>这方面的部署工具有 <strong>Ansible</strong>，<strong>Chef</strong>，<strong>Puppet</strong> 等，我们内部用的是 <strong>Ansible</strong> 来做部署。</p>
<h2 id="团队建设">团队建设 <a class="markdownIt-Anchor" href="#团队建设">#</a></h2>
<p>如何保持团队增长是一个难题！说白了，就是想让大家一起开开心写代码，同时个人也能有所成长收获。</p>
<p>一个<strong>Team Leader</strong>的成功更重要的是取决于他/她的存在是否推进了公司的成功，尤其是技术相关方面的成功，另外他的存在是否帮助了团队里每个工程师的成功，帮助他/她们作为一个个体的成长和成熟。</p>
<h3 id="技术分享">技术分享 <a class="markdownIt-Anchor" href="#技术分享">#</a></h3>
<p>前端技术瞬息万变，库，框架，工具集，开发流程，测试，CI/CD等等，基本上每隔三个月就会更新换代，这就要求我们时刻保持更新，自我成长，多去接触更广阔的世界。</p>
<p>我们内部每周四定期会有一个Tech Talk，针对某一项技术（无论前后端，新或是旧，只要有用），或是一个大家平常遇到的项目问题，或是技术调研的结果。分享的目的在于将自己所了解的东西以最简单的方式讲给大家听，然后自己和其他人在这个过程中都能有所成长。</p>
<p>关于技术分享更多的主题，可以参考<a href="https://trello.com/b/7GoAEqNs/active-front-end-tech-talk">Trello Board</a>。</p>
<h3 id="code-reivew">Code Reivew <a class="markdownIt-Anchor" href="#code-reivew">#</a></h3>
<p>写代码可以帮助我们快速成长，同样的，作为一个代码审核人，也是一个自我学习和成长的过程。代码审核最重要的好处就是帮助我们最大限度的确保<strong>代码质量</strong>，统一代码风格，提早发现Bugs。同时，这也能帮助我们建立一个健康的工程师文化，促进团队成员之间的沟通，保持代码的简洁和可维护性。</p>
<p>代码审核绝对不是指责的工具，同事之间相互的CR过程中，我们也能从彼此那里学到很多编程技巧，并且培养起很好的编程习惯，<strong>学习和成长</strong>才是核心目的。</p>
<p>为了规范化CR流程，我们会把CR加入到我们开发流程中来，尽量自动化整个流程，另外，针对CR，我们也有一些行为准则：</p>
<ul>
<li>使用 <strong>Gitlab Merge Request</strong> 来管理 CR</li>
<li>每个 CR 必须满足 <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">SRP</a> 原则，每次只关注某某一个功能</li>
<li>提交 CR 后，必须确保 CI 是成功的</li>
<li>使用 <strong>precommit hook</strong> 来做代码规范或是自动化测试检查，而不是留到 CR 中</li>
<li>每个人都要参与 CR 中，而不只是 Senior 工程师来对 Junior 工程师做的</li>
<li>在代码提交到主干分支前做 CR（<code>pre-commit</code> CR），而不是合并到主干分支之后</li>
<li>每次提交审核的代码必须少于 400 行，避免提交数几个文件或是数千行代码</li>
</ul>
<blockquote>
<p>推荐使用 <a href="https://github.com/typicode/husky">husky</a> 来实现 <strong>Git hooks</strong>。</p>
</blockquote>

      
    </div>
    <div  dir="ltr" class="level article-bar is-mobile">
      <div class="level-item has-text-centered">
        <a title="previous page" class="previouse-article-link" href="../active/2017-10-23-active-china-fee-hiring-process.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a>
      </div>
      <div class="level-item has-text-centered">
        <a title="font size" class="link-item link-item-size">
          <span class="icon icon-size" data-icon="size"></span>
        </a>
      </div>
      <div class="level-item has-text-centered">
        <a title="table of content" class="link-item link-item-toc">
          <span class="icon icon-toc" data-icon="toc"></span>
        </a>
      </div>
      <div class="level-item has-text-centered">
        <a title="top" href="#">
          <span class="icon icon-up" data-icon="up"></span>
          <span class="link-content">⤊ Top</span>
        </a>
      </div>
      <div class="level-item has-text-centered">
        <a title="next page" class="next-article-link" href="../react/index.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a>
      </div>
    </div>
  </div>
  <div class="column is-2-widescreen is-hidden">
  </div>
</div>

<div class="columns foot">
  <div class="column is-8 is-offset-1 license">
    <p>网站内容许可证：公共领域（public domain）</p>
  </div>
  <div class="column is-3 build-by">
    Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.4.4
  </div>
</div>

<div class="book-toc notification is-warning is-hidden">
  <h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close </a></span></h3>
  <ul class="chapter-area"><li class="chapter-item "><a href="../active/index.html">ACTIVE</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-collapse" data-icon="collapse"></span></a></li><ul class="chapter-level-1 chapter-level-1-current"><li class="chapter-item "><a href="../active/2017-09-25-active-development-workflow.html">活跃网络前端开发流程</a></li><li class="chapter-item "><a href="../active/2017-10-23-active-china-fee-hiring-process.html">活跃网络前端工程师招聘流程</a></li><li class="chapter-item chapter-item-current"><a href="../active/2017-10-19-front-end-engineering-in-active.html">活跃网络的前端工程化实践之路</a></li></ul><li class="chapter-item "><a href="../react/index.html">React</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item "><a href="../react/2017-06-04-how-we-structure-react-redux-project-stucture.html">我们如何组织 React + Redux 项目结构</a></li><li class="chapter-item "><a href="../react/2017-09-08-the-simplicity-of-redux.html">Redux的简单性</a></li><li class="chapter-item "><a href="../react/2017-09-18-how-do-we-implement-i18n-based-on-react.html">我们如何基于 React 实现 i18n</a></li></ul></ul>
</div>

<div class="progress-indicator"></div>

<!-- SCRIPTS -->
<script>
  var LOPPO = {};
  LOPPO.current_path = 'active/2017-10-19-front-end-engineering-in-active.md';
  LOPPO.relative_root_path = '../';
  LOPPO.article_toc = "<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%8E%86%E5%8F%B2\">前端架构历史</a></li>\n<li><a href=\"#%E5%89%8D%E7%AB%AF%E6%A0%87%E5%87%86%E5%8C%96\">前端标准化</a>\n<ul>\n<li><a href=\"#%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9A%84-css-%E6%A1%86%E6%9E%B6\">企业级的 <code>CSS</code> 框架</a></li>\n<li><a href=\"#%E5%9F%BA%E4%BA%8E-react-%E7%9A%84-ui-%E7%BB%84%E4%BB%B6%E5%BA%93\">基于 React 的 <strong>UI</strong> 组件库</a></li>\n<li><a href=\"#git-%E5%B7%A5%E4%BD%9C%E6%B5%81\">Git 工作流</a></li>\n<li><a href=\"#git-%E6%8F%90%E4%BA%A4%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F\">Git 提交消息格式</a></li>\n<li><a href=\"#%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B\">前端技术选型</a></li>\n<li><a href=\"#%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B\">开发流程</a></li>\n<li><a href=\"#%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84\">项目目录结构</a></li>\n<li><a href=\"#%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97%E5%92%8C%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83eslint-prettier\">风格指南和代码规范（ESLint + Prettier）</a></li>\n<li><a href=\"#%E6%B5%8B%E8%AF%95\">测试</a></li>\n<li><a href=\"#%E8%87%AA%E5%8A%A8%E5%8C%96-cicd\">自动化 - CI/CD</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%8F%91%E5%B8%83\">发布</a></li>\n<li><a href=\"#%E9%83%A8%E7%BD%B2\">部署</a></li>\n<li><a href=\"#%E5%9B%A2%E9%98%9F%E5%BB%BA%E8%AE%BE\">团队建设</a>\n<ul>\n<li><a href=\"#%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB\">技术分享</a></li>\n<li><a href=\"#code-reivew\">Code Reivew</a></li>\n</ul>\n</li>\n</ul>\n";
</script>
<script src="../assets/js/app.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?8abfc12836cb16954eaaccc965864e54";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
</body>
</html>

