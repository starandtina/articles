<!DOCTYPE html>
<html>
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta charset="utf-8">
<title>我们如何范式化 Redux 状态的 - Front-End Enginnering</title>
<meta name="description" content="">
<meta name="author" content="">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1">
<link rel="stylesheet" href="../../assets/css/bulma.min.css">
<link rel="stylesheet" href="../../assets/css/app.css">
<!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->
<link rel="shortcut icon" href="">
</head>
<body dir="LTR">

<nav class="columns navbar">
  <div class="column logo is-3 is-offset-1">
    <a class="is-brand" href="../../index.html">
      Front-End Enginnering
    </a>
  </div>
</nav>

<div class="columns content">
  <div class="column is-2-desktop is-3-widescreen is-hidden-touch">
  </div>
  <div class="column article-container is-11-tablet is-8-desktop is-6-widescreen">
    <div class="breadcrumb-area"><a href="../../index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../../Tech/index.html" class="breadcrumb-item">Tech</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../../Tech/React/index.html" class="breadcrumb-item">React</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../../Tech/React/2017-08-07-how-do-we-normalize-state.html" class="breadcrumb-item">我们如何范式化 Redux 状态的</a></div>
    <h1 class="article-title">我们如何范式化 Redux 状态的</h1>
    
  <p>作者：张新</p>


    <div class="article">
      <p>上一篇讲到开发<strong>React + Redux</strong> Web App 时的最佳目录结构，今天想接着聊聊另外一个话题 - Normalizing State（中文一般翻译为<strong>状态范式化</strong>），以及如何利用 selectors 去访问这些数据。</p>
<h2 id="尽量使用索引和selectors分别来存储和访问state">尽量使用索引和<em>selectors</em>分别来存储和访问<em>state</em> <a class="markdownIt-Anchor" href="#尽量使用索引和selectors分别来存储和访问state">#</a></h2>
<p>设计范式化的 State 范式化的数据主要包含下面几个概念：</p>
<ul>
<li>任何类型的数据在<em>state</em>中都有自己的『表』结构</li>
<li>任何『数据表』应将各个项目存储在对象中，其中每个项目的<em>ID</em>作为<em>key</em>，项目本身作为<em>value</em></li>
<li>任何对单个项目的引用都应该根据存储项目的<em>ID</em>来完成</li>
<li><em>ID</em>数组应该用于排序</li>
</ul>
<p>与原始的嵌套形式相比，有下面几个地方的改进：</p>
<ul>
<li>每个数据项只在一个地方定义，不会造成数据的不一致或是冗余，如果数据项需要更新的话不用在多处改变</li>
<li><em>reducer</em>逻辑不用处理深层次的嵌套</li>
<li>检索或者更新给定数据项的逻辑变得简单与一致</li>
<li>提高性能，每个组件只负责更新自己的数据源，不需要更新整个数据源。比如，<em>user</em>属于一个 company，那么更新 company 时，仅仅只需要更新<code>companys.byId[companyId]</code>这部分，这也就意味着在<em>UI</em>中只有数据发生变化的一部分才会发生更新。如果是之前的话，由于是<code>user -&gt; company</code>结构，更新 company 时，同时也会更新<em>user</em>，还有整个<em>user</em>列表，从而会让 connect 到<em>user</em>列表的所有组件全部再次重新渲染。</li>
</ul>
<p>如果你想了解更多关于状态范式化的基本概念和它所带来的好处，请参考<a href="http://redux.js.org/docs/recipes/reducers/NormalizingStateShape.html">Redux 官方文档</a>。</p>
<p>先说一下结果，我们最终所期望的 entities<em>state</em>是这样的：</p>
<pre class="hljs"><code>{
  &quot;readers&quot;: {
    &quot;byId&quot;: {},
    &quot;ids&quot;: []
  },
  &quot;users&quot;: {
    &quot;byId&quot;: {},
    &quot;ids&quot;: []
  },
  &quot;subReaders&quot;: {
    &quot;byId&quot;: {},
    &quot;ids&quot;: []
  },
  &quot;shareUsers&quot;: {
    &quot;byId&quot;: {},
    &quot;ids&quot;: []
  },
  &quot;readerTags&quot;: {
    &quot;byId&quot;: {},
    &quot;ids&quot;: []
  },
  &quot;companys&quot;: {
    &quot;byId&quot;: {},
    &quot;ids&quot;: []
  }
}
</code></pre>
<p>其中，<em>byId</em>就是一个大的<em>hashmap</em>来存储数据，而<em>ids</em>存储的则是有序的所有的<em>id</em>集合。</p>
<p>在状态范式化以前，如果我们想要筛选出一个特定的<em>user</em>对象，那么我们就不得不去迭代所有的<em>users</em>，如果<em>users</em>很大的话，这将是一个非常耗时的操作。如果我们还想对<em>users</em>根据搜索条件筛选出它的一个子集呢？我们可能会另外在状态树中再单独维护一个数组用于保持筛选结果。</p>
<p>而现在，如果我们需要根据<em>useId</em>查找该<em>user</em>，那么我们可以这样简单地做：</p>
<pre class="hljs"><code>export const selectUser = createDeepEqualSelector(
  [getUsers, getUserId],
  (users, userId) =&gt; users.get(String(userId), Map()),
)
</code></pre>
<p>使用范式化数据后，它并不需要我们再去迭代整个列表，这样做不仅节约了时间而且还简化了代码逻辑。</p>
<blockquote>
<p>为了区分<em>selector</em>函数，所有<em>selectors</em>默认都是以<strong>select</strong>为前缀。</p>
</blockquote>
<p>另外，我们经常会做的一件事情就是根据范式化的数据结构来渲染整个列表数据（如<em>users</em>列表），现在我们可以用另外一个<em>selector</em>来实现，它接受<em>users</em>对象列表和<em>users ids</em> 数组，从而返回所有的<em>users</em>列表数据，同时我们可以重用该<em>selector</em>。</p>
<pre class="hljs"><code>const getUsers =*state*=&gt; state.users.byId
const getUserIds =*state*=&gt; state.users.ids
const selectUsers = createDeepEqualSelector(
  [getUsers, getUserIds],
  (users, userIds) =&gt; userIds.map(id =&gt; users.get(String(id))),
)
</code></pre>
<p>同样的，我们还可以用另外一个<em>selector</em>来获取筛选后的<em>users</em>：</p>
<pre class="hljs"><code>export const selectShareUsers = createDeepEqualSelector(
  [getShareUsers, getShareUserIds],
  (shareUsers, shareUserIds) =&gt;
    shareUserIds
      .map(id =&gt; shareUsers.get(String(id)))
      .sortBy(item =&gt; item.get('companyName')),
)
</code></pre>
<blockquote>
<p>我们使用了<strong>reselect</strong>来作为我们的<em>selector</em>库，它会为我们带来如下的优势：</p>
</blockquote>
<ul>
<li><em>Selectors</em>用于计算派生数据，从而允许 Redux 只存储尽可能少的状态</li>
<li><em>Selectors</em>效率相当高，一个<em>selector</em>只有在它的参数发生变化时才会重新计算</li>
<li><em>Selectors</em>可以自由组合，一个<em>selector</em>可以成为其它<em>selector</em>的输入</li>
</ul>
<p>这样一来，我们就实现了数据的存储和获取，同时，<em>selector</em>模式也增强了代码的可维护性。<em>Selectors</em>中封装的是<em>Web App</em>所需要的当前 state 的所有信息，所以我们只需要将<em>Web App</em>的当前<em>state</em>传递给它，它自己会知道如何计算出我们需要的数据，<strong>这样做的好处是可以把组件和<em>state</em>彻底解耦</strong>。</p>
<p>设想一下，如果哪天我们想要重构我们的<em>state</em>（比如<code>users</code>-&gt; <code>xxooUsers</code>，:(）。如果没有<em>selectors</em>，那么我们就必须根据新的<em>state</em>（<code>xxooUsers</code>）去更新我们所有的视图组件代码（例如 <code>mapStateToProps</code>中获取<em>users</em>的代码逻辑），更糟糕的是，随着有类似这种更新需求的视图组件越来越多，这种更新将会越来越困难，如果此时你没有<strong>UT</strong>给你足够的信心加持，那简直 是一场噩梦。为了避免这种牵一发而动全身的问题，最简单的方法是使用<em>selectors</em>在视图组件中获取我们需要的<em>state</em>，如果<em>state</em>结构有任何修改，那么我们只需要更新<em>selector</em>，就可以让它能正确的访问到<em>state</em>，好处是所有的视图组件根本不需要做任何的修改，也可以继续正常工作。</p>
<h2 id="那么我们是如何范式化-state-的呢">那么我们是如何范式化 state 的呢？ <a class="markdownIt-Anchor" href="#那么我们是如何范式化-state-的呢">#</a></h2>
<p>与服务端的数据交互通常是通过严格的 RESTFul API 的形式，我们需要在将该数据需要引入状态树之前转化为规范化形态。<a href="https://github.com/paularmstrong/normalizr">Normalizr</a> 库可以帮助实现这个。你可以定义 schema 的类型和关系，将 schema 和响应数据提供给 Normalizr，他会输出响应数据的范式化变换。</p>
<p>下面是 schema 的定义示例：</p>
<pre class="hljs"><code>import { schema } from 'normalizr'

const reader = new schema.Entity('readers')
const subReader = new schema.Entity('subReaders', {}, { idAttribute: 'rid' })
const readerInfo = new schema.Entity('readerInfos')
const readerTag = new schema.Entity('readerTags')
const company = new schema.Entity('companys')
const user = new schema.Entity('users', { company })
const shareUser = new schema.Entity('shareUsers')
const account = new schema.Entity('accounts')

export default {
  READERS: [reader],

  SUB_READERS: [subReader],

  READER_INFOS: [readerInfo],

  READER_TAGS: [readerTag],

  USER: user,

  SHARE_USERS: [shareUser],

  ACCOUNTS: [account],

  COMPANY: company,
  COMPANYS: [company],
}
</code></pre>
<p>由于内部采用了 PromiseMiddlware 来处理异步数据请求，每个异步请求都会由一个 action 发出，如果需要对服务端的返回数据做 Normalizing，那么只需要在<code>meta</code>上添加上相应的 schema，那么 PromiseMiddleware 会自动根据该 schema 和响应数据生成范式化数据。</p>
<pre class="hljs"><code>export const fetchReaders = ({ suppressLoading } = {}) =&gt; ({
  type: FETCH_READERS,
  promise: (dispatch, getState, api) =&gt; api.get(URL.fetchReaders),
  meta: { suppressLoading, schema: Schemas.READERS },
})
</code></pre>
<pre class="hljs"><code>...
if (schema) {
  finalPayload = normalize(payload, schema)
}

if (meta &amp;&amp; meta.normalize) {
  finalPayload = meta.normalize(payload, { dispatch, getState })
}
...
</code></pre>
<p>最后，范式化的数据会由相应的<code>entities</code>中的<em>reducer</em>做处理，然后存储到<code>entites.readers</code>中。</p>
<pre class="hljs"><code>const readersById = handleActions(
  {
    [DELETE_READER_SUCCESS]: (state, { meta }) =&gt;
      state.filter((r, id) =&gt; id !== String(meta.reader)),

    [ADD_READER_SUCCESS]: (state, { payload }) =&gt;
      state.merge({
        [payload.id]: payload,
      }),

    [FETCH_READER_INFO_SUCCESS]: (state, { payload }) =&gt;
      state.mergeDeepIn([String(payload.id)], payload),

    [SAVE_READER_INFO_SUCCESS]: (state, { payload }) =&gt;
      state.mergeDeepIn([String(payload.id)], payload),
  },
  Map(),
  (state, action) =&gt; entityById('readers')(state, action),
)

const readers = handleActions(
  {
    [DELETE_READER_SUCCESS]: (state, { meta }) =&gt;
      state.filter(id =&gt; id !== meta.reader),

    [ADD_READER_SUCCESS]: (state, { payload }) =&gt; state.concat(payload.id),

    [FETCH_READER_INFO_SUCCESS]: (state, { payload }) =&gt;
      state.concat(payload.id),
  },
  OrderedSet(),
  (state, action) =&gt; entity('readers')(state, action),
)

export default combineReducers({
  byId: readersById,
  ids: readers,
})
</code></pre>

      
    </div>
    <div  dir="ltr" class="level article-bar is-mobile">
      <div class="level-item has-text-centered">
        <a title="previous page" class="previouse-article-link" href="../../Tech/React/2017-06-04-how-we-structure-react-redux-project-stucture.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a>
      </div>
      <div class="level-item has-text-centered">
        <a title="font size" class="link-item link-item-size">
          <span class="icon icon-size" data-icon="size"></span>
        </a>
      </div>
      <div class="level-item has-text-centered">
        <a title="table of content" class="link-item link-item-toc">
          <span class="icon icon-toc" data-icon="toc"></span>
        </a>
      </div>
      <div class="level-item has-text-centered">
        <a title="top" href="#">
          <span class="icon icon-up" data-icon="up"></span>
          <span class="link-content">⤊ Top</span>
        </a>
      </div>
      <div class="level-item has-text-centered">
        <a title="next page" class="next-article-link" href="../../Tech/React/2017-09-08-the-simplicity-of-redux.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a>
      </div>
    </div>
  </div>
  <div class="column is-2-widescreen is-hidden">
  </div>
</div>

<div class="columns foot">
  <div class="column is-8 is-offset-1 license">
    <p>网站内容许可证：公共领域（public domain）</p>
  </div>
  <div class="column is-3 build-by">
    Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.4.4
  </div>
</div>

<div class="book-toc notification is-warning is-hidden">
  <h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close </a></span></h3>
  <ul class="chapter-area"><li class="chapter-item "><a href="../../Life/index.html">Life</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item "><a href="../../Life/2016-08-30-keys-to-have-health-relationship.html">作为一个开发者，如何去维系和增进健康的人际关系？</a></li><li class="chapter-item "><a href="../../Life/2018-03-13-maintaining-a-healthy-work-life-balance.html">如何在工作和工作中找到一个健康的平衡呢？</a></li></ul><li class="chapter-item "><a href="../../Tech/index.html">Tech</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-collapse" data-icon="collapse"></span></a></li><ul class="chapter-level-1 chapter-level-1-current"><li class="chapter-item "><a href="../../Tech/2017-09-01-checklist-job-offer.html">工作机会的检查清单</a></li><li class="chapter-item "><a href="../../Tech/2017-11-03-front-end-development-process.html">前端开发流程</a></li><li class="chapter-item "><a href="../../Tech/2018-03-14-move-from-sb-to-code.html">我为什么放弃 Sublime Text 而转向 VSC？</a></li><li class="chapter-item "><a href="../../Tech/2018-03-27-my-git-styleguide.html">My Personal Git Styleguide</a></li><li class="chapter-item "><a href="../../Tech/2018-08-25-full-stack-engineering.html">WTF Full-Stack Engineering</a></li><li class="chapter-item "><a href="../../Tech/Active/index.html">Active</a></li><ul class="chapter-level-2"><li class="chapter-item "><a href="../../Tech/Active/2017-09-25-active-development-workflow.html">活跃网络前端开发流程</a></li><li class="chapter-item "><a href="../../Tech/Active/2017-10-19-front-end-engineering-in-active.html">活跃网络的前端工程化实践之路</a></li><li class="chapter-item "><a href="../../Tech/Active/2017-10-23-active-china-fee-hiring-process.html">Active China Front-End Engineer Hiring Process</a></li></ul><li class="chapter-item "><a href="../../Tech/React/index.html">React</a></li><ul class="chapter-level-2"><li class="chapter-item "><a href="../../Tech/React/2017-06-04-how-we-structure-react-redux-project-stucture.html">我们如何组织 React + Redux 项目结构</a></li><li class="chapter-item chapter-item-current"><a href="../../Tech/React/2017-08-07-how-do-we-normalize-state.html">我们如何范式化 Redux 状态的</a></li><li class="chapter-item "><a href="../../Tech/React/2017-09-08-the-simplicity-of-redux.html">Redux 的简单性</a></li><li class="chapter-item "><a href="../../Tech/React/2017-09-18-how-do-we-implement-i18n-based-on-react.html">我们如何基于 React 实现 i18n</a></li></ul></ul></ul>
</div>

<div class="progress-indicator"></div>

<!-- SCRIPTS -->
<script>
  var LOPPO = {};
  LOPPO.current_path = 'Tech/React/2017-08-07-how-do-we-normalize-state.md';
  LOPPO.relative_root_path = '../../';
  LOPPO.article_toc = "<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E5%92%8Cselectors%E5%88%86%E5%88%AB%E6%9D%A5%E5%AD%98%E5%82%A8%E5%92%8C%E8%AE%BF%E9%97%AEstate\">尽量使用索引和<em>selectors</em>分别来存储和访问<em>state</em></a></li>\n<li><a href=\"#%E9%82%A3%E4%B9%88%E6%88%91%E4%BB%AC%E6%98%AF%E5%A6%82%E4%BD%95%E8%8C%83%E5%BC%8F%E5%8C%96-state-%E7%9A%84%E5%91%A2\">那么我们是如何范式化 state 的呢？</a></li>\n</ul>\n";
</script>
<script src="../../assets/js/app.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?8abfc12836cb16954eaaccc965864e54";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
</body>
</html>

